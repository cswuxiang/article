## 单页面设计中性能考虑 ##



1. 引言
>  
 提到单页面的性能，其主要对比于传统页面开发的区别。    
 **浏览器的刷新**或**跳转**都会自动释放与回收其内存。但单页面常常像是APP，常驻于浏览器的内存中（CSS树，DOM树，JS对象），业务有功能集合在同一容器中运行，长时间如果不进行回收，特别对于一些定时器，DOM树，事件引用将会页面不断消耗内存，影响运行性能。


2.设计好坏

> 当你的页面长期运行后，再次在页面中交互时，不影响其流畅性。这里对比于操作系统与web服务器，当长期开机或启动web服务后，其**保鲜度**作为其体验标准。

3.单页面myspa回收

> 1、单页面视图管理

背景 ： 假设一个单页面有A,B,C,D,E五个页面。用户首页面访问了A-->B-->C--D-->B-->C-->E
这一过程主要产生两个问题：  

>>1. 重复访问B,C产生重复对象问题 ?   


**影响**

 myspa是基于seajs，而seajs的入口是seajs.use对于B,C的**重复**访问都会生成**新的引用对象**，耗损计算与内存。

![seajs.use方式](http://i1.piimg.com/567571/b7942655d8b38e8a.png)


![多余对象](http://i1.piimg.com/567571/94004986f196a32f.jpg)

**方案**  

  虚拟一层加载器loader，对模块状态统一管理。
 
 ![loader](http://p1.bpimg.com/567571/6e989011e481258d.jpg)


>>2、A页面长期未用，占用资源问题 ？

**影响**   

 假设A长期未使用，是否一直占用着内存。如果A本身占用很大内存呢，进一步C,D,E等都未使用却占用大量内存，当再次运行其它View时，导致交互**响应延时**。

**方案**  
 
 增加定时器，以定时检查空闲时间，达到即回收。
 ![定时器](http://i1.piimg.com/567571/a163a361a34d2ab4.jpg)


> 2、单页面事件机制

  传统页面，刷新或跳转都会将事件绑定释放，但单页面视图切换过程中，上一视图事件是否需要回收，以及事件绑定时机都需重新考虑。

**方案**  

  根DOM代理注入，自动回收。

  ![单页面事件机制](http://p1.bpimg.com/567571/e0b84069375e119a.jpg)


> 3、单页面定时器
  
  开发人员只关注创建定时器，而非销毁。单页的切换往往像轮询场景。

  **方案**  

  虚拟定时器，自动回收。

  ![单页面事件机制](http://p1.bpimg.com/567571/6ca0c8d228f2e031.jpg)


3.扩展内容

> 常见的内存回收模式

- 标记-清除算法【Mark and Sweep】

标记清除（Mark and Sweep）是**最早开发出的GC算法**（1960年）。它的原理非常简单，首先从**根**开始将可能被**引用的对象**用递归的方式进行标记，然后将**没有标记**到的对象作为**垃圾**进行回收。

**不足**：这种方式会产生大量的内存碎片，就导致了可用内存不规整。下次对于大的内存分配会导致不足，将再次提前触发回收。

![](http://i1.piimg.com/567571/9881418ce5757755.png)



- 标记-整理算法【Mark and Compact】

 记的过程和标记-清除算法一样，但是**标记完成之后**，让所有存活的对象都向**堆内存的一端移动**，最后直接**清除掉边界以外的内存**。这样对内存进行回收之后，内存是规整的，于是可以使用指针碰撞的方式分配新的内存。

![](http://p1.bqimg.com/567571/0e90e7ca39c22de4.png)

**不足** ： 大量分配对象中，只有少部分存活时，消耗的运行时间过长。

- 复制收集算法【Copy and Collection】

  会将从**根**开始被引用的对象**复制到另外的空间**中，然后，再将**复制的对象**所能够**引用**的对象用**递归的方式不断复制下去**。

![](http://p1.bpimg.com/567571/d93b5fd21bb9af94.png)

**不足**：由于存在移动复制，“存活”对象比例较高的情况下，反而会比较不利。 


----------
上面提到了几种基础GC算法，但是各自的各自的优点，必须放到适合的场景内才能发挥最大的效率，接下来看常见应用所采用的策略。


> 常用场景回收方式


- JVM管理模式

JVM化分两部分：新生代(young generate)和老年代(old generation)

新生代：复制收集算法; 适合大量刚分配与过期对象较高。

新生代划分为三个部分：分别为Eden、Survivor from、Survivor to，大小比例为8：1：1（为了防止复制收集算法的浪费内存过大）

老年代：标记-清理或标记-整理算法;适合GC频率低。

![](http://i1.piimg.com/567571/2861576d6752a410.png)





- Node管理模式

Node其低层是基于V8引擎，所以此重点讨论V8的方案。

V8采用了一种**分代回收**的策略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象。老生代中的对象为存活时间较长或常驻内存的对象。跟JVM的方案其实很相似，V8在执行**垃圾回收时会阻塞JavaScript应用逻辑**，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。所以需要**限制使用内存的大小**。



- JavaScript 垃圾回收            

Java,Node 一样JavaScript有自动垃圾回收机制，也就是说执行环境会负责管理代码执行过程中使用的内存，在开发过程中就无需考虑内存分配及无用内存的回收问题了。JavaScript垃圾回收的机制很简单.

- 标记清除[mark and sweep]
JavaScript对象

- 引用计数[reference counting] (IE 6, 7)
DOM对象

> 参考文章

- [浅析JVM之内存管理](https://segmentfault.com/a/1190000000440270   )
- [浅谈V8引擎中的垃圾回收机制](https://segmentfault.com/a/1190000004926898) 
- [构建单页Web应用](https://github.com/xufei/blog/issues/5)
- [NodeJS中被忽略的内存](http://huang-jerryc.com/2016/04/14/NodeJS%E4%B8%AD%E8%A2%AB%E5%BF%BD%E7%95%A5%NodeJS中被忽略的内存E7%9A%84%E5%86%85%E5%AD%98/)
- [内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)


